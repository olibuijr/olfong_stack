# √ñlf√∂ng Wine & Beer Shop Platform - Cursor Rules

## üîß **MCP Server Configuration**

```json
{
  "mcpServers": {
    "playwright": {
      "command": "docker",
      "args": ["run", "-i", "--rm", "--init", "--pull=always", "mcr.microsoft.com/playwright/mcp"]
    },
    "filesystem": {
      "command": "npx",
      "args": ["-y", "@modelcontextprotocol/server-filesystem", "/home/olibuijr/Projects/olfong_stack"]
    },
    "context7": {
      "command": "npx",
      "args": ["-y", "@upstash/context7-mcp"],
      "env": {
        "CONTEXT7_API_KEY": "ctx7sk-5e739f0a-6b8b-4b4f-9c3b-0c5d42fe8f3d"
      }
    },
    "everything": {
      "command": "npx",
      "args": ["-y", "@modelcontextprotocol/server-everything"]
    },
    "git": {
      "command": "npx",
      "args": ["-y", "@modelcontextprotocol/server-filesystem"]
    },
    "brave-search": {
      "command": "npx",
      "args": ["-y", "@modelcontextprotocol/server-brave-search"],
      "env": {
        "BRAVE_API_KEY": "BSA_JQdHt3Pt9mmLWQ0i7mPrfSpeN2u"
      }
    },
    "memory": {
      "command": "npx",
      "args": ["-y", "@modelcontextprotocol/server-memory"]
    },
    "postgres": {
      "command": "npx",
      "args": ["-y", "@henkey/postgres-mcp-server", "--connection-string", "postgresql://olfong_user:olfong_password@localhost:5432/olfong_db?schema=public"]
    }
  }
}
```

### **MCP Server Setup Instructions**

1. **Open Cursor Settings**: Press `Cmd + ,` (macOS) or `Ctrl + ,` (Windows/Linux)
2. **Navigate to MCP**: Go to `Settings` > `Features` > `MCP`
3. **Add Configuration**: Copy the JSON configuration above into the MCP settings
4. **Verify Servers**: Ensure all servers show green status indicators
5. **Test Integration**: Use natural language commands to invoke MCP tools

### **Available MCP Servers**

- **Playwright**: Automated web and mobile app testing
- **Filesystem**: Secure file system access and analysis
- **Context7**: Latest documentation and API references
- **Everything**: Comprehensive MCP protocol features and utilities
- **Git**: Version control operations and history
- **Brave Search**: Web search capabilities
- **Memory**: Persistent memory and context storage
- **PostgreSQL**: Database querying and analysis

### **MCP Tool Usage Guidelines**

#### **üé≠ Playwright Tool**
```bash
# Test web application functionality
"Use the playwright tool to test the login flow"
"Use the playwright tool to take a screenshot of the homepage"
"Use the playwright tool to test mobile responsiveness"
"Use the playwright tool to test the checkout process"
"Use the playwright tool to validate form submissions"
```

#### **üìÅ Filesystem Tool**
```bash
# Analyze and read project files
"Use the filesystem tool to read the server.js file"
"Use the filesystem tool to analyze the backend authentication code"
"Use the filesystem tool to find all TODO comments in the codebase"
"Use the filesystem tool to check for security vulnerabilities"
"Use the filesystem tool to examine the database schema"
```

#### **üìö Context7 Tool**
```bash
# Get latest documentation and API references
"Use the context7 tool to get React documentation"
"Use the context7 tool to find Node.js best practices"
"Use the context7 tool to get Prisma ORM examples"
"Use the context7 tool to find Express.js patterns"
"Use the context7 tool to get Tailwind CSS documentation"
```

#### **üõ†Ô∏è Everything Tool**
```bash
# Comprehensive MCP protocol features
"Use the everything tool to show available features"
"Use the everything tool to demonstrate MCP capabilities"
"Use the everything tool to test protocol features"
"Use the everything tool to get utility functions"
```

#### **üîç Git Tool**
```bash
# Version control operations
"Use the git tool to show recent commits"
"Use the git tool to check the current branch status"
"Use the git tool to find files changed in the last commit"
"Use the git tool to show commit history"
"Use the git tool to check for uncommitted changes"
```

#### **üåê Brave Search Tool**
```bash
# Web search capabilities
"Use the brave-search tool to find React best practices"
"Use the brave-search tool to search for Node.js security tips"
"Use the brave-search tool to find e-commerce patterns"
"Use the brave-search tool to research payment gateway integration"
"Use the brave-search tool to find testing strategies"
```

#### **üß† Memory Tool**
```bash
# Persistent memory and context storage
"Use the memory tool to store project context"
"Use the memory tool to remember user preferences"
"Use the memory tool to save important decisions"
"Use the memory tool to track project milestones"
"Use the memory tool to store code patterns"
```

#### üóÑÔ∏è PostgreSQL Tool
```bash
# Database querying and analysis
"Use the postgres tool to query all users"
"Use the postgres tool to find orders from last week"
"Use the postgres tool to show the database schema"
"Use the postgres tool to find products with low stock"
"Use the postgres tool to analyze user behavior patterns"
"Use the postgres tool to query translation data for a specific language"
```

### **MCP Development Workflow**

#### **üîç Code Analysis Workflow**
1. **Filesystem Tool**: Read and analyze code files
2. **Git Tool**: Check commit history and changes
3. **Context7 Tool**: Get latest documentation
4. **Brave Search Tool**: Research best practices
5. **Memory Tool**: Store analysis results

#### **üß™ Testing Workflow**
1. **Playwright Tool**: Test UI functionality
2. **PostgreSQL Tool**: Verify database state
3. **Filesystem Tool**: Check test files
4. **Memory Tool**: Store test results

#### **üêõ Debugging Workflow**
1. **PostgreSQL Tool**: Query database for issues
2. **Filesystem Tool**: Analyze error logs
3. **Git Tool**: Check recent changes
4. **Playwright Tool**: Reproduce issues
5. **Memory Tool**: Track debugging progress

#### **üìö Research Workflow**
1. **Context7 Tool**: Get framework documentation
2. **Brave Search Tool**: Find solutions online
3. **Everything Tool**: Explore MCP capabilities
4. **Memory Tool**: Store research findings

### **MCP Tool Integration Examples**

#### **Feature Development**
```bash
# 1. Research phase
"Use the context7 tool to get React documentation"
"Use the brave-search tool to find e-commerce patterns"

# 2. Analysis phase  
"Use the filesystem tool to analyze existing code"
"Use the git tool to check recent changes"

# 3. Implementation phase
"Use the postgres tool to verify database schema"
"Use the memory tool to store implementation decisions"

# 4. Testing phase
"Use the playwright tool to test the new feature"
"Use the postgres tool to verify data integrity"
```

#### **Bug Investigation**
```bash
# 1. Reproduce issue
"Use the playwright tool to reproduce the bug"

# 2. Analyze logs
"Use the filesystem tool to check error logs"
"Use the postgres tool to query affected data"

# 3. Check changes
"Use the git tool to find recent commits"
"Use the filesystem tool to analyze changed files"

# 4. Store findings
"Use the memory tool to store bug analysis"
```

#### **Performance Optimization**
```bash
# 1. Analyze current state
"Use the postgres tool to analyze slow queries"
"Use the filesystem tool to check code patterns"

# 2. Research solutions
"Use the context7 tool to get optimization docs"
"Use the brave-search tool to find performance tips"

# 3. Implement and test
"Use the playwright tool to test performance"
"Use the postgres tool to verify improvements"
```

## ü§ñ OpenCode AI Assistant Integration

This project is designed to work with **OpenCode**, an open source AI coding agent built for the terminal. OpenCode provides:

- **Native TUI**: Responsive terminal UI with themeable interface
- **LSP Enabled**: Automatic loading of language servers for intelligent code assistance
- **Multi-session**: Parallel agent sessions for complex tasks
- **Share Links**: Shareable session links for collaboration and debugging
- **Any Model**: Support for 75+ LLM providers through Models.dev, including local models
- **Any Editor**: Terminal-based operation compatible with any IDE
- **Privacy First**: No storage of code or context data for sensitive environments

### OpenCode Usage Guidelines
- Use OpenCode for code analysis, refactoring suggestions, and implementation assistance
- Leverage OpenCode's LSP integration for intelligent code completion and error detection
- Utilize multi-session capability for parallel development tasks
- Share session links for collaborative debugging and code review
- Access OpenCode's extensive model support for specialized coding tasks
- **MCP Server Integration**: Utilize configured MCP servers for enhanced capabilities
  - **Filesystem MCP**: Read and analyze project files securely (read-only access)
  - **Git MCP**: Perform git operations, check status, view history, and manage branches
  - **PostgreSQL MCP**: Query and analyze the project database (olfong_db) for data insights
  - **Playwright MCP**: Automate web and mobile app testing, capture screenshots, and validate UI
  - **GitHub Grep MCP**: Search GitHub repositories for code examples and documentation
   - Use natural language commands like "Use the postgres tool to query user data" or "Use the playwright tool to test the login flow"
- **Process Management**: Use the MCP process manager script for reliable process management
  - Start services: `./backend/mcp-process-manager.sh start-backend/start-frontend/start-all`
  - Monitor logs: `./backend/mcp-process-manager.sh logs <service>`
  - Stop services: `./backend/mcp-process-manager.sh stop <service>/stop-all`
  - List processes: `./backend/mcp-process-manager.sh list`
  - Health checks: `./backend/mcp-process-manager.sh health-check`
  - Continuous monitoring: `./backend/mcp-process-manager.sh monitor`
- **Multi-Agent Workflows**: Spawn multiple agents for parallel tasks to speed up development
   - Use separate agent sessions for different aspects (e.g., one for backend analysis, one for frontend testing)
   - Coordinate agents for complex tasks like full-stack feature implementation
   - Leverage agent specialization: web-search agent for research, database agent for data operations, fullstack agent for comprehensive development
   - Share context between agents using session links for collaborative problem-solving

## ‚öôÔ∏è **Process Management System**

**CRITICAL**: This project uses a dedicated process management script for all service operations. You MUST use this script for any process management tasks.

### Process Management Script Location
- **Script Path**: `./process-manager.sh`
- **Usage**: `./process-manager.sh [command] [service]`
- **Services**: `backend`, `frontend`, `all`

### Available Commands
- **Start Services**: `./process-manager.sh start [backend|frontend|all]`
- **Stop Services**: `./process-manager.sh stop [backend|frontend|all]`
- **Restart Services**: `./process-manager.sh restart [backend|frontend|all]`
- **Service Status**: `./process-manager.sh status`
- **View Logs**: `./process-manager.sh logs [backend|frontend]`
- **Follow Logs**: `./process-manager.sh follow [backend|frontend]`
- **Health Check**: `./process-manager.sh health`
- **Run Linting**: `./process-manager.sh lint [backend|frontend|all]`
- **Run Tests**: `./process-manager.sh test [backend|frontend|all]`
- **Cleanup**: `./process-manager.sh cleanup`

### Process Management Guidelines
- **ALWAYS** use `./process-manager.sh` for process operations
- **NEVER** run direct npm commands or start services manually
- **AUTOMATIC LINTING**: The script runs linting before starting services
- **HEALTH MONITORING**: Use `./process-manager.sh health` for service health checks
- **LOG MANAGEMENT**: Use `./process-manager.sh logs` and `./process-manager.sh follow` for monitoring

### Process Management Examples
```bash
# Start all services
./process-manager.sh start all

# Start only backend
./process-manager.sh start backend

# Check service status
./process-manager.sh status

# View backend logs
./process-manager.sh logs backend

# Follow frontend logs
./process-manager.sh follow frontend

# Run health check
./process-manager.sh health

# Run linting for all services
./process-manager.sh lint all

# Stop all services
./process-manager.sh stop all
```

### Service Configuration
- **Backend Port**: 5000
- **Frontend Port**: 3001
- **Log Directory**: `./logs/`
- **PID Directory**: `./.pids/`
- **Automatic Dependency Installation**: Script installs dependencies if missing
- **Pre-start Validation**: Linting runs before service startup

## üß™ **Playwright Test Suite Issues & Fixes**

### **Current Test Failures (High Priority)**

#### **1. Authentication System Mismatch**
- **Issue**: Customer login page uses Kenni electronic ID, not email/password
- **Tests Expect**: `getByLabel('Email')` and `getByLabel('Password')` fields
- **Reality**: Only Kenni login + dummy phone login + test email/password form
- **Fix**: Tests should use the "Automated Test Login" button and form

#### **2. Admin Login Redirect**
- **Issue**: Admin login redirects to `/` instead of `/admin`
- **Fix Applied**: Updated AdminLogin.jsx to redirect admin users to `/admin`
- **Test Status**: Should now pass

#### **3. Homepage Content Mismatch**
- **Issue**: Tests expect "Featured Products" heading
- **Reality**: Homepage shows categories section with "Categories"/"Flokkar" heading
- **Fix Applied**: Updated test to look for category headings

#### **4. Search Functionality**
- **Issue**: Tests expect search button, but search triggers on input change
- **Reality**: No search button, search happens live as you type
- **Fix Applied**: Updated test to fill search input without clicking button

#### **5. Category Filtering**
- **Issue**: Tests look for "Wine" button, but UI shows "V√≠n" (Icelandic)
- **Fix Applied**: Updated test to match both English and Icelandic text

#### **6. Test Data Missing**
- **Issue**: Tests expect `test@example.com` user
- **Fix Applied**: Added test customer to database seed script

### **Test Execution Instructions**

#### **Critical: Stop at Errors and Fix Before Continuing**
- **IMMEDIATE STOP**: When encountering test failures, STOP execution immediately and fix the root cause before running additional tests
- **Single Issue Focus**: Address one test failure at a time - do not run the full test suite until the current issue is resolved
- **Root Cause Analysis**: Analyze error messages, screenshots, and logs to understand the underlying problem before attempting fixes
- **Incremental Validation**: After fixing an issue, run only the affected test(s) to verify the fix before proceeding
- **Prevention Strategy**: This approach prevents cascading failures and ensures each fix is validated independently

#### **Focused Testing Strategy - DO NOT Run Full Test Suite Repeatedly**
- **AVOID FULL SUITE RUNS**: Do NOT run `npm test` (full test suite) repeatedly during debugging sessions
- **TARGETED TESTING**: When fixing code, run ONLY the specific test(s) that relate to your changes
- **EXAMPLE COMMANDS**:
  ```bash
  # Instead of: npm test (runs all tests)
  # Use these focused approaches:

  # Run specific test file
  cd web-tests && npx playwright test e2e/admin/admin-settings.spec.ts

  # Run specific test by name pattern
  cd web-tests && npx playwright test --grep "VAT settings"

  # Run specific test category
  cd web-tests && npm run test:admin

  # Run only authentication tests
  cd web-tests && npx playwright test e2e/auth/
  ```
- **EFFICIENCY RULE**: If you've made code changes, test ONLY those affected areas before proceeding
- **FULL SUITE TIMING**: Reserve full test suite runs for final validation or CI/CD pipelines only

#### **Proactive Issue Resolution - Fix All Problems Without Asking**
- **AUTOMATIC FIXING**: When encountering any issues, bugs, or test failures, immediately implement fixes without asking for user permission
- **COMPREHENSIVE RESOLUTION**: Address ALL identified problems in the current session, not just the immediate issue
- **NO APPROVAL REQUIRED**: Do not ask "would you like me to..." or "should I..." - just implement the necessary fixes
- **COMPLETE SOLUTIONS**: Ensure all related issues are resolved before moving to the next task
- **SELF-DIRECTED WORKFLOW**: Analyze problems, implement solutions, and validate fixes independently

#### **Code-First Test Fixing - Prioritize Bug Fixes Over Test Adaptation**
- **FIX CODE, NOT TESTS**: When tests fail due to application bugs, fix the underlying code issues rather than modifying tests to work around bugs
- **ROOT CAUSE RESOLUTION**: Identify and fix the actual bugs causing test failures, not just adapt tests to accommodate broken functionality
- **PROPER IMPLEMENTATION**: Ensure features are correctly implemented before expecting tests to pass
- **QUALITY ASSURANCE**: Tests should validate working functionality, not accommodate broken code
- **PREVENTIVE MAINTENANCE**: Fix bugs proactively to prevent test failures and improve overall code quality

#### **Before Running Tests**:
```bash
# 1. Install system dependencies (if missing browser libraries)
# On Ubuntu/Debian:
sudo apt-get update
sudo apt-get install -y libjpeg-dev libwebp-dev libffi-dev

# 2. Start all services
cd backend && ./mcp-process-manager.sh start-all

# 3. Ensure database is seeded
cd backend && node prisma/seed.js

# 4. Verify frontend is on port 3001
curl -s http://localhost:3001 | head -5
```

#### **Running Tests (Headless)**:
```bash
cd web-tests
npx playwright test --headed=false
```

**IMPORTANT**: Playwright tests are configured to run headless by default. The `headless: true` setting in `playwright.config.ts` ensures tests run without opening browser windows, making them suitable for CI/CD environments and automated testing.

#### **Test-Specific Fixes Needed**:

1. **Customer Login Tests**: Update to use test login form
    ```javascript
    // Instead of:
    await page.getByLabel('Email').fill(email);
    await page.getByLabel('Password').fill(password);

    // Use:
    await page.getByRole('button', { name: 'Automated Test Login' }).click();
    await page.getByLabel('Email').fill(email);
    await page.getByLabel('Password').fill(password);
    await page.getByRole('button', { name: 'Login with Email' }).click();
    ```

2. **Product Search Tests**: Remove search button click
    ```javascript
    // Instead of:
    await page.getByRole('button', { name: 'Search' }).click();

    // Just fill the input (search happens automatically)
    await page.getByPlaceholder(/Search/).fill('wine');
    ```

3. **Category Filter Tests**: Handle bilingual UI
    ```javascript
    // Instead of:
    await page.getByRole('button', { name: 'Wine' }).click();

    // Use regex for both languages:
    await page.getByRole('button', { name: /Wine|V√≠n/i }).click();
    ```

4. **Cart Management Tests**: Ensure authentication before cart operations
    ```javascript
    // Always login explicitly in cart tests:
    await page.goto('/login');
    await page.getByRole('button', { name: 'Automated Test Login' }).click();
    await page.getByLabel('Email').fill(testUsers.customer.email);
    await page.getByLabel('Password').fill(testUsers.customer.password);
    await page.getByRole('button', { name: 'Login with Email' }).click();
    await expect(page.getByRole('button', { name: 'User menu' })).toBeVisible();
    ```

5. **Admin-Customer Chat Tests**: Test real-time communication
    ```javascript
    // Use multiple browser contexts for concurrent admin/customer sessions:
    const adminContext = await browser.newContext();
    const customerContext = await browser.newContext();
    const adminPage = await adminContext.newPage();
    const customerPage = await customerContext.newPage();

    // Test message exchange between admin and customer
    // Verify chat persistence and real-time updates
    ```

### **Known Test Issues to Address**

#### **Immediate Fixes Needed**:
- ‚úÖ **Database seeding**: Test customer added
- ‚úÖ **Admin redirect**: Fixed in AdminLogin.jsx
- ‚úÖ **Homepage test**: Updated to match actual content
- ‚úÖ **Search test**: Updated to work without button
- ‚úÖ **Category test**: Updated for bilingual support
- ‚ùå **Customer login tests**: Still need to be updated to use test login form

#### **Long-term Improvements**:
- Add dedicated test login endpoint that bypasses Kenni authentication
- Create test-specific user interface that doesn't require UI interactions
- Add API helpers for direct user creation/deletion in tests
- Implement proper test data cleanup between test runs

### **Test Maintenance Guidelines**

1. **UI Changes**: Update test selectors when UI components change
2. **New Features**: Add corresponding test cases for new functionality
3. **Authentication**: Use test login form or API helpers for auth testing
4. **Data Dependencies**: Ensure test data exists before running tests
5. **Bilingual Support**: Use regex patterns for Icelandic/English text

### **Quick Test Verification**

```bash
# Check if services are running
cd backend && ./mcp-process-manager.sh list

# Quick health check
curl -s http://localhost:5000/api/health | jq .status
curl -s http://localhost:3001 | grep -o "<title>.*</title>"
```

**CRITICAL**: Always use MCP servers for all operations to ensure proper monitoring, logging, and resource management.

## üîÑ **Self-Healing Test Infrastructure**

### **Enhanced Test Utilities (test-utils.ts)**

The test suite includes advanced self-healing capabilities:

#### **Retry Mechanisms**
- **Automatic Retries**: Failed operations retry up to 3 times with exponential backoff
- **Smart Timeouts**: Extended timeouts (15s actions, 45s navigation) for reliable execution
- **Graceful Degradation**: Fallback strategies when primary selectors fail

#### **Intelligent Element Detection**
- **Multiple Selector Strategies**: Tests try multiple selectors for the same element
- **Dynamic Element Waiting**: Smart waiting that adapts to page load states
- **Text-Based Fallbacks**: Automatic fallback to text content when selectors fail

#### **Robust Login System**
- **Multi-Strategy Authentication**: Supports both test login and regular login flows
- **Automatic Fallback**: Falls back to regular login if test login fails
- **Session Verification**: Confirms successful authentication before proceeding

#### **Enhanced Cart Operations**
- **Smart Product Selection**: Automatically finds and clicks available products
- **State Verification**: Ensures cart operations complete successfully
- **Error Recovery**: Handles cart state inconsistencies gracefully

#### **Performance Monitoring**
- **Operation Timing**: Measures and logs execution time for all operations
- **Bottleneck Detection**: Identifies slow operations for optimization
- **Resource Usage Tracking**: Monitors memory and CPU usage during tests

#### **Health Check Integration**
- **Pre-Test Validation**: Verifies all services are healthy before running tests
- **Real-time Monitoring**: Continuous health checks during test execution
- **Automatic Recovery**: Attempts to restart failed services

### **Self-Healing Test Patterns**

#### **Selector Resilience**
```typescript
// Instead of single selector:
await page.getByTestId('cart-item').toHaveCount(1);

// Use multiple strategies:
await waitForElement(page, [
  '[data-testid="cart-item"]',
  '.card.p-6',
  '.cart-item'
]);
```

#### **Operation Reliability**
```typescript
// Instead of direct operations:
await page.click('button');

// Use enhanced operations:
await clickElement(page, [
  'button:has-text("Add to Cart")',
  'button:has-text("B√¶ta √≠ k√∂rfu")', // Icelandic fallback
  '[data-testid="add-to-cart"]'
]);
```

#### **State-Aware Testing**
```typescript
// Verify application state before actions:
await waitForServices();
await loginUser(page, email, password);
await verifyCartState(page);
```

### **Monitoring & Logging Enhancements**

#### **Comprehensive Reporting**
- **HTML Reports**: Detailed test execution reports with screenshots
- **JSON Output**: Machine-readable results for CI/CD integration
- **Step-by-Step Logging**: Verbose logging of all test operations

#### **Failure Analysis**
- **Screenshot Capture**: Automatic screenshots on failures
- **Video Recording**: Full test execution videos for debugging
- **Error Context**: Detailed error information with stack traces

#### **Performance Metrics**
- **Execution Timing**: Per-test and per-operation timing
- **Resource Monitoring**: Memory and CPU usage tracking
- **Bottleneck Identification**: Automatic detection of slow operations

### **Proactive Issue Detection**

#### **UI Change Detection**
- **Selector Validation**: Automatically detects when UI selectors change
- **Layout Monitoring**: Identifies layout shifts and responsiveness issues
- **Accessibility Checks**: Validates WCAG compliance during testing

#### **Data Consistency**
- **Database Verification**: Ensures test data integrity between runs
- **State Synchronization**: Verifies frontend/backend state consistency
- **Cache Validation**: Checks cached data validity

#### **Network Resilience**
- **Connection Monitoring**: Detects and handles network interruptions
- **API Reliability**: Validates API responses and handles failures
- **Real-time Updates**: Monitors WebSocket connections and real-time features

### **Continuous Improvement**

#### **Learning from Failures**
- **Pattern Recognition**: Learns from past failures to prevent recurrence
- **Adaptive Timeouts**: Adjusts timeouts based on historical performance
- **Selector Optimization**: Refines selectors based on success rates

#### **Test Suite Evolution**
- **Automatic Test Generation**: Suggests new tests for uncovered code paths
- **Coverage Analysis**: Identifies areas needing additional test coverage
- **Maintenance Alerts**: Flags tests that need updating due to code changes

### **Proactive Feature Suggestions**

#### **Missing Feature Detection**
- **Gap Analysis**: Automatically identifies missing features or incomplete implementations
- **Best Practice Recommendations**: Suggests improvements based on industry standards
- **Security Enhancements**: Identifies potential security vulnerabilities or improvements
- **Performance Optimizations**: Detects performance bottlenecks and suggests fixes

#### **Implementation Proposals**
- **Feature Requests**: When encountering limitations, suggest specific feature implementations
- **API Extensions**: Propose new API endpoints or modifications for better functionality
- **UI/UX Improvements**: Suggest interface enhancements for better user experience
- **Integration Opportunities**: Identify potential third-party integrations

#### **Mandatory Implementation Rule**
- **"To Be Implemented" Features**: If any code contains comments, TODOs, or placeholders indicating features that are "to be implemented", "TODO", "FIXME", or similar markers, these MUST be implemented immediately without waiting for user approval
- **Code Completion**: Treat any incomplete implementations as critical issues that require immediate resolution
- **Self-Healing Code**: Automatically implement any stubbed, mocked, or placeholder functionality found in the codebase
- **No Deferred Features**: Do not leave any "to be implemented" features in the code - implement them as part of the current session

#### **Confirmation Protocol**
- **Clear Proposals**: Present feature suggestions with detailed benefits and implementation scope
- **Wait for Approval**: Always wait for explicit user confirmation before implementing suggestions (except for "to be implemented" features)
- **Alternative Options**: Provide multiple implementation approaches when applicable
- **Rollback Plans**: Include reversion strategies for any implemented changes

## ‚öôÔ∏è **Command Timeout Configuration**

### **Default Command Timeouts**
- **Standard Commands**: 120,000ms (2 minutes) - for most operations
- **Test Commands**: 300,000ms (5 minutes) - for comprehensive test suites
- **Build Commands**: 600,000ms (10 minutes) - for compilation and bundling
- **Database Operations**: 180,000ms (3 minutes) - for migrations and seeding
- **Network Operations**: 60,000ms (1 minute) - for API calls and downloads

### **Timeout Override Guidelines**
- **Long-running Tests**: Use `timeout 300000` prefix for extended test execution
- **Complex Builds**: Use `timeout 600000` prefix for large application builds
- **Database Operations**: Use `timeout 180000` prefix for schema changes and data operations
- **Network-dependent Tasks**: Use `timeout 120000` prefix for operations requiring external services

## üö´ CRITICAL: MANDATORY PROCESS MANAGEMENT

**ALWAYS use the management script (./process-manager.sh) to manage all application processes. NEVER run, build, start, or execute any of the following commands directly:**

### ‚ùå FORBIDDEN DIRECT COMMANDS
- `npm run dev` - Backend/Frontend development servers
- `npm start` - Backend production server
- `npm run build` - Frontend production build
- `node server.js` - Direct server execution
- `vite` - Direct Vite execution
- `npm install` - Package installation (handled by process manager)
- `yarn *` - Any yarn command execution
- `pnpm *` - Any pnpm command execution
- `docker *` - Any Docker command execution
- `docker-compose *` - Any Docker Compose command execution
- `make *` - Any Make command execution
- `./*` - Any executable script execution (except process-manager.sh)

### ‚úÖ MANDATORY PROCESS MANAGEMENT
**ALWAYS use the process management script for ALL service operations:**

```bash
# Start services
./process-manager.sh start all

# Stop services  
./process-manager.sh stop all

# Check status
./process-manager.sh status

# View logs
./process-manager.sh logs backend
./process-manager.sh logs frontend

# Health check
./process-manager.sh health

# Run linting
./process-manager.sh lint all

# Run tests
./process-manager.sh test all
```

### ‚úÖ ALLOWED DIRECT COMMANDS (Database Operations Only)
- `npx prisma migrate dev` - Database migrations (schema changes)
- `npx prisma generate` - Prisma client generation
- `node prisma/seed.js` - Database seeding
- `npx prisma studio` - Database management interface

### Process Management Benefits
- **Automatic Linting**: Runs linting before starting services
- **Health Monitoring**: Built-in health checks and monitoring
- **Log Management**: Centralized logging and log following
- **Dependency Management**: Automatic dependency installation
- **Process Tracking**: PID management and process monitoring
- **Graceful Shutdown**: Proper service termination
- **Error Handling**: Comprehensive error detection and reporting

## üîç **MANDATORY CODE VALIDATION REQUIREMENTS**

**CRITICAL**: Before declaring any code fix or implementation complete, you MUST run validation checks.

### Required Validation Steps
1. **Linting Check**: `./process-manager.sh lint [service]`
2. **TypeScript Check**: `./process-manager.sh test [service]` (includes type checking)
3. **Service Health**: `./process-manager.sh health`
4. **Process Status**: `./process-manager.sh status`

### Validation Workflow
```bash
# 1. Make code changes
# 2. Run linting
./process-manager.sh lint all

# 3. Run type checking and tests
./process-manager.sh test all

# 4. Check service health
./process-manager.sh health

# 5. Verify process status
./process-manager.sh status
```

### Code Quality Standards
- **Zero Linting Errors**: All code must pass ESLint without warnings
- **Zero TypeScript Errors**: All code must pass TypeScript compilation
- **Service Health**: All services must be running and healthy
- **Process Validation**: All processes must be properly managed

### Failure Handling
- **Linting Failures**: Fix all linting errors before proceeding
- **TypeScript Failures**: Fix all type errors before proceeding
- **Service Failures**: Restart services and verify health
- **Process Issues**: Use process manager to diagnose and fix

### Validation Commands Reference
```bash
# Check specific service
./process-manager.sh lint backend
./process-manager.sh test backend

# Check all services
./process-manager.sh lint all
./process-manager.sh test all

# Health and status
./process-manager.sh health
./process-manager.sh status

# View validation logs
./process-manager.sh logs backend
./process-manager.sh logs frontend
```

## üìã Project Overview

This is a **PRODUCTION-READY** e-commerce platform for √ñlf√∂ng wine and beer shop with:

### Architecture
- **Backend**: Node.js + Express + SQLite/PostgreSQL + Prisma
- **Web Frontend**: React.js + Vite + Tailwind CSS + Redux Toolkit
- **Mobile Apps**: React Native (TypeScript) + Flutter (Dart)
- **Real-time**: Socket.IO for live updates and delivery tracking
- **Authentication**: JWT + Kenni IDP integration
- **Payments**: Valitor payment gateway
- **Maps**: OpenStreetMap integration (no API key required)

### Key Features
- Complete e-commerce functionality (products, cart, checkout, orders)
- Advanced subscription system for recurring orders
- Flexible delivery options (home delivery + store pickup)
- Comprehensive admin panel for managing all aspects
- Complete delivery dashboard with GPS tracking
- Multi-language support (Icelandic/English)
- Real-time updates via Socket.IO
- Mobile-responsive design with dedicated mobile apps

### Project Structure
```
olfong_stack/
‚îú‚îÄ‚îÄ backend/                    # Node.js Express API Server
‚îÇ   ‚îú‚îÄ‚îÄ prisma/                 # Database schema and migrations
‚îÇ   ‚îú‚îÄ‚îÄ src/                    # Source code (controllers, routes, middleware, services, utils)
‚îÇ   ‚îú‚îÄ‚îÄ uploads/                # Product image storage
‚îÇ   ‚îú‚îÄ‚îÄ scripts/                # Database seeding and utility scripts
‚îÇ   ‚îú‚îÄ‚îÄ package.json            # Backend dependencies and scripts
‚îÇ   ‚îî‚îÄ‚îÄ server.js               # Main server entry point
‚îú‚îÄ‚îÄ web/                        # React.js Web Application
‚îÇ   ‚îú‚îÄ‚îÄ src/                    # React components, pages, services, store, locales
‚îÇ   ‚îú‚îÄ‚îÄ dist/                   # Built application assets
‚îÇ   ‚îú‚îÄ‚îÄ package.json            # Frontend dependencies and scripts
‚îÇ   ‚îî‚îÄ‚îÄ vite.config.js          # Vite build configuration
‚îú‚îÄ‚îÄ olfong_mobile_flutter/      # Flutter Mobile Application
‚îÇ   ‚îú‚îÄ‚îÄ lib/                    # Dart source code
‚îÇ   ‚îú‚îÄ‚îÄ android/                # Android platform configuration
‚îÇ   ‚îú‚îÄ‚îÄ ios/                    # iOS platform configuration
‚îÇ   ‚îú‚îÄ‚îÄ pubspec.yaml            # Flutter dependencies
‚îÇ   ‚îî‚îÄ‚îÄ README.md               # Flutter app documentation
‚îú‚îÄ‚îÄ shared/                     # Shared assets and constants
‚îÇ   ‚îî‚îÄ‚îÄ logo_black-web.webp     # Shared logo asset
‚îú‚îÄ‚îÄ .cursor/                    # Cursor IDE screenshots and assets
‚îú‚îÄ‚îÄ .cursorrules               # This rules file for AI assistants
‚îú‚îÄ‚îÄ README.md                   # Comprehensive project documentation
‚îú‚îÄ‚îÄ docker-compose.yml          # Docker container orchestration
‚îú‚îÄ‚îÄ integration_test_report.md  # Integration testing reports
‚îú‚îÄ‚îÄ test_integration.js         # Integration test scripts
‚îî‚îÄ‚îÄ .env                        # Environment configuration files (backend/web)
```

## üéØ Development Guidelines

### **API Communication Rules**
- **ALWAYS use direct backend calls**: Frontend must call backend directly at `http://localhost:5000/api/*`
- **NO PROXYING**: Never use Vite proxy or any other proxying mechanism
- **CORS HANDLED**: Backend is configured to handle CORS for direct frontend calls
- **Environment Variables**: Use `VITE_API_URL=http://localhost:5000/api` for API base URL

### What You CAN Do
- ‚úÖ Read and analyze code files
- ‚úÖ Suggest code improvements and optimizations
- ‚úÖ Help with debugging and troubleshooting
- ‚úÖ Explain code functionality and architecture
- ‚úÖ Suggest new features and enhancements
- ‚úÖ Help with code refactoring
- ‚úÖ Assist with documentation updates
- ‚úÖ Review and suggest security improvements
- ‚úÖ Help with testing strategies
- ‚úÖ Suggest performance optimizations
- ‚úÖ Database schema changes and migrations
- ‚úÖ Prisma client generation
- ‚úÖ Database seeding for initial setup
- ‚úÖ **MANDATORY LINTING**: Always run linting before assuming code is fixed
- ‚úÖ **MANDATORY TYPE CHECKING**: Always run TypeScript checks before assuming code is fixed
- ‚úÖ **PROCESS MANAGEMENT**: Use `./process-manager.sh` for all service operations
- ‚úÖ **MCP Server Utilization**: Leverage configured MCP servers for enhanced development
  - ‚úÖ **Filesystem MCP**: Securely read and analyze project files (read-only access)
  - ‚úÖ **Git MCP**: Perform git operations, check status, view commit history, and manage branches
  - ‚úÖ **PostgreSQL MCP**: Query and analyze the project database (olfong_db) for data insights and validation
  - ‚úÖ **Playwright MCP**: Automate web and mobile app testing, capture screenshots, and validate UI interactions
  - ‚úÖ **Context7 MCP**: Access latest documentation and API references for frameworks and libraries
  - ‚úÖ **Everything MCP**: Use comprehensive MCP protocol features and utilities
  - ‚úÖ **Brave Search MCP**: Search the web for best practices, patterns, and solutions
  - ‚úÖ **Memory MCP**: Store persistent context, decisions, and project information
  - ‚úÖ Use natural language commands to invoke MCP tools (e.g., "Use the postgres tool to find all orders" or "Use the playwright tool to test the checkout flow")
  - ‚úÖ **Process Management**: Use MCP servers for all process management operations
- ‚úÖ **Multi-Agent Workflows**: Spawn multiple agents for parallel development tasks
  - ‚úÖ Use separate agent sessions for different domains (backend, frontend, testing, documentation)
  - ‚úÖ Coordinate agents for complex tasks like full-stack feature implementation
  - ‚úÖ Leverage specialized agents: web-search for research, database for data operations, fullstack for comprehensive development
  - ‚úÖ Share context between agents using session links for collaborative problem-solving
- ‚úÖ **Context7 Documentation**: Use Context7 MCP server for latest documentation before making assumptions
  - ‚úÖ Search for framework and library documentation
  - ‚úÖ Get up-to-date API references and examples
  - ‚úÖ Verify implementation patterns and best practices
  - ‚úÖ Check compatibility and version-specific information
  - ‚úÖ Access official documentation for technologies used
- ‚úÖ **Playwright Testing**: Use Playwright MCP server for UI and app testing
  - ‚úÖ Test web application functionality and user flows
  - ‚úÖ Test mobile applications (React Native/Flutter)
  - ‚úÖ Perform cross-browser testing
  - ‚úÖ Test API endpoints and responses
  - ‚úÖ Generate and compare screenshots
  - ‚úÖ Test accessibility and performance
  - ‚úÖ Create automated test scenarios

### What You CANNOT Do
- ‚ùå Run any build or start commands directly
- ‚ùå Execute any npm/yarn/pnpm scripts directly (except database operations)
- ‚ùå Start development servers without using process manager
- ‚ùå Execute mobile app builds or runs
- ‚ùå Install dependencies directly (handled by process manager)
- ‚ùå Run any system commands that could affect the environment
- ‚ùå Execute any commands that start processes or services directly
- ‚ùå Assume code is fixed without running linting and type checking
- ‚ùå Skip validation steps before declaring code complete

## üîß Build Process Information

### **API Communication Architecture**
- **Frontend**: React app on port 3001
- **Backend**: Express API on port 5000
- **Communication**: Direct HTTP calls (no proxy)
- **CORS**: Configured for cross-origin requests
- **Environment**: `VITE_API_URL=http://localhost:5000/api`

The application uses manual build processes outside of AI chat:

### Backend Setup (Manual Process)
1. Navigate to `backend/` directory
2. Run `npm install` to install dependencies
3. Run `npx prisma migrate dev --name init` for database setup
4. Run `node prisma/seed.js` to seed the database
5. Run `npm run dev` to start the development server

### Web Frontend Setup (Manual Process)
1. Navigate to `web/` directory
2. Run `npm install` to install dependencies
3. Run `npm run dev` to start the development server

### React Native Mobile Setup (Manual Process)
1. Navigate to `mobile/` directory
2. Run `npm install` to install dependencies
3. Run `npm start` to start Metro bundler
4. Run `npm run android` or `npm run ios` to launch the app

### Flutter Mobile Setup (Manual Process)
1. Navigate to `olfong_mobile_flutter/` directory
2. Run `flutter pub get` to install dependencies
3. Run `flutter run` to launch the app

## üì± Access Information

### Default URLs (when manually started)
- **Web App**: http://localhost:3001
- **API**: http://localhost:5000/api
- **Admin Login**: username: `admin`, password: `admin`
- **Delivery Login**: username: `delivery1`, password: `delivery123`

### Database
- **Development**: SQLite (`file:./dev.db`)
- **Production**: PostgreSQL (configurable)
- **Schema**: Comprehensive with users, products, orders, subscriptions, etc.

## üö® Important Notes

1. **This is a PRODUCTION-READY application** - all core features are implemented and functional
2. **Manual build process** - All builds and runs are handled outside of AI chat
3. **Multiple platforms** - Web, React Native, and Flutter applications are all functional
4. **Real-time features** - Socket.IO integration for live updates and delivery tracking
5. **Payment integration** - Valitor payment gateway fully implemented
6. **Multi-language support** - Icelandic/English throughout all applications
7. **Role-based access** - Customer, Admin, and Delivery personnel with proper permissions

## üéØ Focus Areas for AI Assistance

When helping with this project, focus on:
- Code analysis and optimization suggestions
- Feature enhancement recommendations
- Security best practices
- Performance improvements
- Testing strategies and implementation
- Documentation improvements
- Architecture refinements
- Bug identification and fixes
- Code review and quality improvements
- Database schema improvements and migrations
- **MCP Server Integration**: Utilize configured MCP servers for enhanced capabilities
  - **Filesystem MCP**: Analyze project structure and read files for context
  - **Git MCP**: Review commit history, branch management, and code changes
  - **PostgreSQL MCP**: Query database for data validation and insights
  - **Playwright MCP**: Automate testing and UI validation
  - **GitHub Grep MCP**: Research code patterns and best practices
  - **PersistProc MCP**: Manage development server processes and monitor logs
- **Multi-Agent Workflows**: Spawn multiple agents for parallel development
  - Use agents for simultaneous tasks (e.g., one analyzing backend, another testing frontend)
  - Coordinate agents for complex implementations requiring multiple perspectives
  - Leverage specialized agents for research, database operations, and full-stack development
- **UI/App Testing**: Leverage Playwright MCP server for comprehensive testing
  - Web application testing and user flow validation
  - Mobile app testing across platforms
  - Cross-browser compatibility testing
  - API endpoint testing and validation
  - Visual regression and accessibility testing
  - Performance and load testing

## üöÄ Development Guidelines & Best Practices

### Code Quality Standards
- **Consistency**: Follow existing code patterns and conventions
- **TypeScript**: Prefer TypeScript over JavaScript for new components
- **Error Handling**: Implement proper error handling with user-friendly messages
- **Validation**: Use express-validator for backend validation and react-hook-form for frontend
- **Security**: Always validate and sanitize user inputs
- **Performance**: Optimize database queries and implement proper indexing
- **Accessibility**: Ensure WCAG compliance for web components
- **MANDATORY VALIDATION**: Always run linting and type checking before declaring code complete

### Development Workflow Requirements
1. **Code Changes**: Make necessary code modifications
2. **Linting Check**: Run `./process-manager.sh lint [service]` to validate code style
3. **Type Checking**: Run `./process-manager.sh test [service]` to validate types
4. **Service Health**: Run `./process-manager.sh health` to verify services
5. **Process Status**: Run `./process-manager.sh status` to confirm all processes
6. **Documentation**: Update relevant documentation if needed

### Pre-Commit Validation Checklist
- [ ] Code passes ESLint without warnings
- [ ] Code passes TypeScript compilation
- [ ] All services are running and healthy
- [ ] Process manager shows correct status
- [ ] No console errors in logs
- [ ] All tests pass (if applicable)
- [ ] Documentation updated (if needed)

### Architecture Patterns
- **Backend**: Follow MVC pattern with controllers, routes, middleware, and services
- **Frontend**: Use Redux Toolkit for state management with proper slice organization
- **Mobile**: Implement role-based navigation and consistent state management
- **Database**: Use Prisma ORM with proper relationships and constraints
- **Real-time**: Leverage Socket.IO for live updates and notifications

### File Organization
- **Components**: Organize by feature/domain (admin, auth, common, layout)
- **Pages**: Group by user role (admin, customer, delivery)
- **Services**: Separate API calls and business logic
- **Utils**: Keep utility functions organized by purpose
- **Types**: Define TypeScript interfaces in dedicated files

### Naming Conventions
- **Files**: Use PascalCase for components, camelCase for utilities
- **Variables**: Use descriptive names with proper prefixes (is, has, can, should)
- **Functions**: Use verb-noun pattern (getUser, updateOrder, validateInput)
- **Constants**: Use UPPER_SNAKE_CASE for constants
- **Database**: Use snake_case for table and column names

### Error Handling
- **Backend**: Use try-catch blocks with proper error responses
- **Frontend**: Implement error boundaries and toast notifications
- **Database**: Handle constraint violations gracefully
- **API**: Return consistent error format with proper HTTP status codes
- **Logging**: Log errors with sufficient context for debugging

### Security Considerations
- **Authentication**: Use JWT tokens with proper expiration
- **Authorization**: Implement role-based access control
- **Input Validation**: Validate all inputs on both client and server
- **SQL Injection**: Use Prisma ORM to prevent SQL injection
- **XSS Protection**: Sanitize user inputs and use proper escaping
- **CORS**: Configure CORS properly for production
- **Rate Limiting**: Implement rate limiting for API endpoints

### Performance Optimization
- **Database**: Use proper indexing and query optimization
- **Frontend**: Implement code splitting and lazy loading
- **Images**: Optimize images and use appropriate formats
- **Caching**: Implement caching strategies for frequently accessed data
- **Bundle Size**: Monitor and optimize bundle sizes
- **Real-time**: Optimize Socket.IO events and room management

### Testing Strategy
- **Unit Tests**: Test individual functions and components
- **Integration Tests**: Test API endpoints and database interactions
- **E2E Tests**: Test complete user workflows
- **Mocking**: Mock external services and dependencies
- **Coverage**: Maintain good test coverage for critical paths
- **Playwright MCP Server**: Available for comprehensive UI and app testing
  - **Web Application Testing**: Test React.js web app functionality, user flows, and UI interactions
  - **Mobile App Testing**: Test React Native and Flutter mobile applications
  - **Cross-browser Testing**: Test web app across different browsers and devices
  - **API Testing**: Test backend API endpoints and responses
  - **Visual Regression Testing**: Compare screenshots for UI changes
  - **Performance Testing**: Measure page load times and user interactions
  - **Accessibility Testing**: Verify WCAG compliance and screen reader compatibility

### Internationalization (i18n)
- **Translation Keys**: Use descriptive, hierarchical key names
- **Pluralization**: Handle plural forms correctly
- **Date/Time**: Use proper locale-specific formatting
- **Currency**: Format currency according to locale
- **RTL Support**: Consider right-to-left language support
- **Translation Backup**: After adding translations, export them using the PostgreSQL MCP server for backup (e.g., "Use the postgres tool to export translation data")

#### Handling Missing Translations
- **Best Practices for Finding Untranslated Strings**:
  - **Frontend Logging**: The frontend's `logMissingTranslation` function (in `web/src/contexts/LanguageContext.tsx`) logs missing keys to `logs/missing-translations.log`. Regularly check this file for new entries.
  - **UI Inspection**: Manually inspect the UI in both English and Icelandic. Any text that remains in English when Icelandic is selected is a candidate for translation.
  - **Code Search**: Search the codebase (especially `.jsx`, `.tsx` files) for hardcoded strings that should be translated. Look for strings not wrapped in `t('...')` or `tWithFallback('...')`.
- **Adding Translations**: When a translation is missing:
  1. **Identify the Key**: Determine a descriptive, hierarchical key name (e.g., `home.hero.subtitle`).
  2. **Update Source Files**: Add the new key and its corresponding English and Icelandic values to `web/src/locales/translations/en.ts` and `web/src/locales/translations/is.ts` respectively.
  3. **Backup Translations**: **CRITICAL**: Before running the seeding script, always back up the current translations in the database. Use the PostgreSQL MCP tool to export translation data to a file.
     ```bash
     # Example: Export all translations to a JSON file
     "Use the postgres tool to export translation data to /path/to/backup/translations_backup_$(date +%Y%m%d%H%M%S).json"
     ```
  4. **Database Insertion**: After updating the `.ts` files, run the `backend/scripts/seedTranslations.js` script to insert or update these translations in the database.
     ```bash
     node backend/scripts/seedTranslations.js
     ```
  5. **Frontend Integration**: Ensure the frontend components use the new translation keys with the `t()` function.
- **Validation**: After seeding, always run linting and type checking to ensure code quality and consistency.
  ```bash
  ./process-manager.sh lint all
  ./process-manager.sh test all
  ```

### Mobile Development
- **Platform Differences**: Handle iOS/Android specific features
- **Navigation**: Use consistent navigation patterns
- **State Management**: Implement proper state persistence
- **Offline Support**: Consider offline functionality for critical features
- **Push Notifications**: Implement proper notification handling
- **Performance**: Optimize for mobile performance and battery usage

### Database Design
- **Relationships**: Define proper foreign key relationships
- **Indexing**: Add indexes for frequently queried columns
- **Constraints**: Use database constraints for data integrity
- **Migrations**: Write reversible migrations with proper rollback
- **Seeding**: Maintain consistent seed data for development
- **Backups**: Implement proper backup strategies

### API Design
- **RESTful**: Follow REST conventions for API endpoints
- **Versioning**: Implement API versioning for backward compatibility
- **Documentation**: Document API endpoints with examples
- **Pagination**: Implement proper pagination for list endpoints
- **Filtering**: Support filtering and sorting options
- **Error Responses**: Use consistent error response format

### Real-time Features
- **Socket.IO**: Use rooms for efficient message broadcasting
- **Event Names**: Use descriptive event names with consistent naming
- **Error Handling**: Handle connection errors gracefully
- **Reconnection**: Implement automatic reconnection logic
- **Scalability**: Consider horizontal scaling for Socket.IO

### Payment Integration
- **Valitor**: Follow Valitor API documentation and best practices
- **Webhooks**: Implement proper webhook handling with verification
- **Error Handling**: Handle payment failures gracefully
- **Security**: Never store sensitive payment data
- **Testing**: Use sandbox environment for testing

### Deployment Considerations
- **Environment Variables**: Use proper environment configuration
- **Database**: Use appropriate database for production
- **SSL**: Implement proper SSL certificates
- **Monitoring**: Set up application monitoring and logging
- **Backups**: Implement automated backup strategies
- **Scaling**: Plan for horizontal scaling if needed

### Code Review Checklist
- [ ] Code follows established patterns and conventions
- [ ] Proper error handling implemented
- [ ] Input validation in place
- [ ] Security considerations addressed
- [ ] Performance optimizations applied
- [ ] Tests written for new functionality
- [ ] Documentation updated if needed
- [ ] Internationalization keys added
- [ ] Mobile compatibility verified
- [ ] Database migrations tested
   - [ ] **MCP Server Integration**: Leveraged appropriate MCP servers for analysis and testing
     - [ ] Filesystem MCP used for code structure analysis
     - [ ] Git MCP used for version control review
     - [ ] PostgreSQL MCP used for database validation
     - [ ] Playwright MCP used for UI testing
     - [ ] Context7 MCP used for latest documentation and API references
     - [ ] Everything MCP used for comprehensive MCP protocol features
     - [ ] Brave Search MCP used for research and best practices
     - [ ] Memory MCP used for storing context and decisions
- [ ] **Multi-Agent Coordination**: Considered parallel agent workflows for complex tasks
  - [ ] Spawned multiple agents for different aspects of the feature
  - [ ] Coordinated agents for comprehensive implementation
  - [ ] Used specialized agents for research, database, and full-stack work
- [ ] **Playwright tests created** for new UI features
- [ ] Cross-browser compatibility verified
- [ ] Accessibility compliance tested
- [ ] Performance benchmarks established

### Common Pitfalls to Avoid
- **Direct Database Access**: Always use Prisma ORM, never raw SQL
- **Hardcoded Values**: Use environment variables for configuration
- **Missing Error Handling**: Always handle potential errors
- **Inconsistent State**: Keep Redux state consistent across components
- **Memory Leaks**: Clean up event listeners and subscriptions
- **Security Vulnerabilities**: Never trust client-side data
- **Performance Issues**: Monitor and optimize database queries
- **Accessibility**: Don't forget about screen readers and keyboard navigation

**Remember**: This application is fully functional and production-ready. The AI's role is to assist with code analysis, suggestions, and improvements, NOT to run or build the application.