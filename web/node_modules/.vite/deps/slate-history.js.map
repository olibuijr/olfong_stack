{
  "version": 3,
  "sources": ["../../is-plain-object/dist/is-plain-object.mjs", "../../slate-history/src/history.ts", "../../slate-history/src/history-editor.ts", "../../slate-history/src/with-history.ts"],
  "sourcesContent": ["/*!\n * is-plain-object <https://github.com/jonschlinkert/is-plain-object>\n *\n * Copyright (c) 2014-2017, Jon Schlinkert.\n * Released under the MIT License.\n */\n\nfunction isObject(o) {\n  return Object.prototype.toString.call(o) === '[object Object]';\n}\n\nfunction isPlainObject(o) {\n  var ctor,prot;\n\n  if (isObject(o) === false) return false;\n\n  // If has modified constructor\n  ctor = o.constructor;\n  if (ctor === undefined) return true;\n\n  // If has modified prototype\n  prot = ctor.prototype;\n  if (isObject(prot) === false) return false;\n\n  // If constructor does not have an Object-specific method\n  if (prot.hasOwnProperty('isPrototypeOf') === false) {\n    return false;\n  }\n\n  // Most likely a plain Object\n  return true;\n}\n\nexport { isPlainObject };\n", "import { isPlainObject } from 'is-plain-object'\nimport { Operation, Range } from 'slate'\n\ninterface Batch {\n  operations: Operation[]\n  selectionBefore: Range | null\n}\n\n/**\n * `History` objects hold all of the operations that are applied to a value, so\n * they can be undone or redone as necessary.\n */\n\nexport interface History {\n  redos: Batch[]\n  undos: Batch[]\n}\n\n// eslint-disable-next-line no-redeclare\nexport const History = {\n  /**\n   * Check if a value is a `History` object.\n   */\n\n  isHistory(value: any): value is History {\n    return (\n      isPlainObject(value) &&\n      Array.isArray(value.redos) &&\n      Array.isArray(value.undos) &&\n      (value.redos.length === 0 ||\n        Operation.isOperationList(value.redos[0].operations)) &&\n      (value.undos.length === 0 ||\n        Operation.isOperationList(value.undos[0].operations))\n    )\n  },\n}\n", "import { BaseEditor, Editor } from 'slate'\nimport { History } from './history'\n\n/**\n * Weakmaps for attaching state to the editor.\n */\n\nexport const HISTORY = new WeakMap<Editor, History>()\nexport const SAVING = new WeakMap<Editor, boolean | undefined>()\nexport const MERGING = new WeakMap<Editor, boolean | undefined>()\nexport const SPLITTING_ONCE = new WeakMap<Editor, boolean | undefined>()\n\n/**\n * `HistoryEditor` contains helpers for history-enabled editors.\n */\n\nexport interface HistoryEditor extends BaseEditor {\n  history: History\n  undo: () => void\n  redo: () => void\n  writeHistory: (stack: 'undos' | 'redos', batch: any) => void\n}\n\n// eslint-disable-next-line no-redeclare\nexport const HistoryEditor = {\n  /**\n   * Check if a value is a `HistoryEditor` object.\n   */\n\n  isHistoryEditor(value: any): value is HistoryEditor {\n    return History.isHistory(value.history) && Editor.isEditor(value)\n  },\n\n  /**\n   * Get the merge flag's current value.\n   */\n\n  isMerging(editor: HistoryEditor): boolean | undefined {\n    return MERGING.get(editor)\n  },\n\n  /**\n   * Get the splitting once flag's current value.\n   */\n\n  isSplittingOnce(editor: HistoryEditor): boolean | undefined {\n    return SPLITTING_ONCE.get(editor)\n  },\n\n  setSplittingOnce(editor: HistoryEditor, value: boolean | undefined): void {\n    SPLITTING_ONCE.set(editor, value)\n  },\n\n  /**\n   * Get the saving flag's current value.\n   */\n\n  isSaving(editor: HistoryEditor): boolean | undefined {\n    return SAVING.get(editor)\n  },\n\n  /**\n   * Redo to the previous saved state.\n   */\n\n  redo(editor: HistoryEditor): void {\n    editor.redo()\n  },\n\n  /**\n   * Undo to the previous saved state.\n   */\n\n  undo(editor: HistoryEditor): void {\n    editor.undo()\n  },\n\n  /**\n   * Apply a series of changes inside a synchronous `fn`, These operations will\n   * be merged into the previous history.\n   */\n  withMerging(editor: HistoryEditor, fn: () => void): void {\n    const prev = HistoryEditor.isMerging(editor)\n    MERGING.set(editor, true)\n    fn()\n    MERGING.set(editor, prev)\n  },\n\n  /**\n   * Apply a series of changes inside a synchronous `fn`, ensuring that the first\n   * operation starts a new batch in the history. Subsequent operations will be\n   * merged as usual.\n   */\n  withNewBatch(editor: HistoryEditor, fn: () => void): void {\n    const prev = HistoryEditor.isMerging(editor)\n    MERGING.set(editor, true)\n    SPLITTING_ONCE.set(editor, true)\n    fn()\n    MERGING.set(editor, prev)\n    SPLITTING_ONCE.delete(editor)\n  },\n\n  /**\n   * Apply a series of changes inside a synchronous `fn`, without merging any of\n   * the new operations into previous save point in the history.\n   */\n\n  withoutMerging(editor: HistoryEditor, fn: () => void): void {\n    const prev = HistoryEditor.isMerging(editor)\n    MERGING.set(editor, false)\n    fn()\n    MERGING.set(editor, prev)\n  },\n\n  /**\n   * Apply a series of changes inside a synchronous `fn`, without saving any of\n   * their operations into the history.\n   */\n\n  withoutSaving(editor: HistoryEditor, fn: () => void): void {\n    const prev = HistoryEditor.isSaving(editor)\n    SAVING.set(editor, false)\n    try {\n      fn()\n    } finally {\n      SAVING.set(editor, prev)\n    }\n  },\n}\n", "import { Editor, Operation, Path, Transforms } from 'slate'\n\nimport { HistoryEditor } from './history-editor'\n\n/**\n * The `withHistory` plugin keeps track of the operation history of a Slate\n * editor as operations are applied to it, using undo and redo stacks.\n *\n * If you are using TypeScript, you must extend Slate's CustomTypes to use\n * this plugin.\n *\n * See https://docs.slatejs.org/concepts/11-typescript to learn how.\n */\n\nexport const withHistory = <T extends Editor>(editor: T) => {\n  const e = editor as T & HistoryEditor\n  const { apply } = e\n  e.history = { undos: [], redos: [] }\n\n  e.redo = () => {\n    const { history } = e\n    const { redos } = history\n\n    if (redos.length > 0) {\n      const batch = redos[redos.length - 1]\n\n      if (batch.selectionBefore) {\n        Transforms.setSelection(e, batch.selectionBefore)\n      }\n\n      HistoryEditor.withoutSaving(e, () => {\n        Editor.withoutNormalizing(e, () => {\n          for (const op of batch.operations) {\n            e.apply(op)\n          }\n        })\n      })\n\n      history.redos.pop()\n      e.writeHistory('undos', batch)\n    }\n  }\n\n  e.undo = () => {\n    const { history } = e\n    const { undos } = history\n\n    if (undos.length > 0) {\n      const batch = undos[undos.length - 1]\n\n      HistoryEditor.withoutSaving(e, () => {\n        Editor.withoutNormalizing(e, () => {\n          const inverseOps = batch.operations.map(Operation.inverse).reverse()\n\n          for (const op of inverseOps) {\n            e.apply(op)\n          }\n          if (batch.selectionBefore) {\n            Transforms.setSelection(e, batch.selectionBefore)\n          }\n        })\n      })\n\n      e.writeHistory('redos', batch)\n      history.undos.pop()\n    }\n  }\n\n  e.apply = (op: Operation) => {\n    const { operations, history } = e\n    const { undos } = history\n    const lastBatch = undos[undos.length - 1]\n    const lastOp =\n      lastBatch && lastBatch.operations[lastBatch.operations.length - 1]\n    let save = HistoryEditor.isSaving(e)\n    let merge = HistoryEditor.isMerging(e)\n\n    if (save == null) {\n      save = shouldSave(op, lastOp)\n    }\n\n    if (save) {\n      if (merge == null) {\n        if (lastBatch == null) {\n          merge = false\n        } else if (operations.length !== 0) {\n          merge = true\n        } else {\n          merge = shouldMerge(op, lastOp)\n        }\n      }\n\n      if (HistoryEditor.isSplittingOnce(e)) {\n        merge = false\n        HistoryEditor.setSplittingOnce(e, undefined)\n      }\n\n      if (lastBatch && merge) {\n        lastBatch.operations.push(op)\n      } else {\n        const batch = {\n          operations: [op],\n          selectionBefore: e.selection,\n        }\n        e.writeHistory('undos', batch)\n      }\n\n      while (undos.length > 100) {\n        undos.shift()\n      }\n\n      history.redos = []\n    }\n\n    apply(op)\n  }\n\n  e.writeHistory = (stack: 'undos' | 'redos', batch: any) => {\n    e.history[stack].push(batch)\n  }\n\n  return e\n}\n\n/**\n * Check whether to merge an operation into the previous operation.\n */\n\nconst shouldMerge = (op: Operation, prev: Operation | undefined): boolean => {\n  if (\n    prev &&\n    op.type === 'insert_text' &&\n    prev.type === 'insert_text' &&\n    op.offset === prev.offset + prev.text.length &&\n    Path.equals(op.path, prev.path)\n  ) {\n    return true\n  }\n\n  if (\n    prev &&\n    op.type === 'remove_text' &&\n    prev.type === 'remove_text' &&\n    op.offset + op.text.length === prev.offset &&\n    Path.equals(op.path, prev.path)\n  ) {\n    return true\n  }\n\n  return false\n}\n\n/**\n * Check whether an operation needs to be saved to the history.\n */\n\nconst shouldSave = (op: Operation, prev: Operation | undefined): boolean => {\n  if (op.type === 'set_selection') {\n    return false\n  }\n\n  return true\n}\n"],
  "mappings": "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",
  "names": ["History", "isHistory", "value", "isPlainObject", "Array", "isArray", "redos", "undos", "length", "Operation", "isOperationList", "operations", "HISTORY", "WeakMap", "SAVING", "MERGING", "SPLITTING_ONCE", "HistoryEditor", "isHistoryEditor", "history", "Editor", "isEditor", "isMerging", "editor", "get", "isSplittingOnce", "setSplittingOnce", "set", "isSaving", "redo", "undo", "withMerging", "fn", "prev", "withNewBatch", "delete", "withoutMerging", "withoutSaving", "withHistory", "e", "apply", "batch", "selectionBefore", "Transforms", "setSelection", "withoutNormalizing", "op", "pop", "writeHistory", "inverseOps", "map", "inverse", "reverse", "lastBatch", "lastOp", "save", "merge", "shouldSave", "shouldMerge", "undefined", "push", "selection", "shift", "stack", "type", "offset", "text", "Path", "equals", "path"]
}
